package co.edu.unicauca.factory.algorithm;

import co.edu.unicauca.factory.parameters.AbstractParametersFactory;
import co.edu.unicauca.problem.AbstractELMEvaluator;
import java.util.Comparator;
import org.uma.jmetal.algorithm.singleobjective.differentialevolution.DECC_GBuilder;
import org.uma.jmetal.algorithm.singleobjective.differentialevolution.DEUnicaucaBuilder;
import org.uma.jmetal.algorithm.singleobjective.differentialevolution.MemeticEDBuilder;
import org.uma.jmetal.algorithm.singleobjective.differentialevolution.SaDEBuilder;
import org.uma.jmetal.algorithm.singleobjective.differentialevolution.SaNSDEBuilder;
import org.uma.jmetal.operator.impl.crossover.DifferentialEvolutionCrossover;
import org.uma.jmetal.operator.impl.selection.DifferentialEvolutionSelection;
import org.uma.jmetal.problem.DoubleProblem;
import org.uma.jmetal.solution.DoubleSolution;
import org.uma.jmetal.util.AlgorithmBuilder;
import org.uma.jmetal.util.JMetalException;
import org.uma.jmetal.util.comparator.ObjectiveComparator;

/**
 * Factory to differential evolution algorithms builders, with configuration
 * needed for elm problem.
 */
public class DifferentialEvolutionFactory extends AbstractBuilderFactory {

	/**
	 * Default configuration for DE
	 */
	private double crDe;
	private double fDe;
	private int POPULATION_DE;
	/**
	 * Default configuration SaDE
	 */
	private double cR1SADE;
	private double f1SADE;
	private double cR2SADE;
	private double f2SADE;
	private int populationSaDE;
	/**
	 * Default configuration SaNSDE
	 */
	private double cR1SANSDE;
	private double f1SANSDE;
	private double cR2SANSDE;
	private double f2SANSDE;
	private int populationSANSDE;
	/**
	 * Default configuration for MemeticDE
	 */
	private double cRMEMETICDE;
	private double fMEMETICDE;
	private int populationMemetic;
	private final static Comparator<DoubleSolution> COMPARATOR_MEMETIC = new ObjectiveComparator<>(0,
			ObjectiveComparator.Ordering.DESCENDING);

	private int dECCGPOPULATION;

	public DifferentialEvolutionFactory(AbstractParametersFactory parametersFactory) {
		super(parametersFactory);

	}

	@Override
	public AlgorithmBuilder getAlgorithm(String name, AbstractELMEvaluator.EvaluatorType evaluatorType,
			DoubleProblem problem) throws Exception {
		this.evaluatorType = evaluatorType;
		int evaluations = evaluatorType == AbstractELMEvaluator.EvaluatorType.TT ? EVALUATIONS_TT : EVALUATIONS_CV;
		AlgorithmBuilder builder = null;
		this.loadAlgorithmValues(name, evaluatorType);
		switch (name) {
		case "DEUnicauca":
			builder = this.getDEUnicauca(evaluations, problem);
			break;
		case "SaDE":
			builder = this.getSaDE(evaluations, problem);
			break;
		case "SaNSDE":
			builder = this.getSaNSDE(evaluations, problem);
			break;
		case "DECC_G":
			builder = this.getDECCG(evaluations, problem);
			break;
		case "MemeticED":
			builder = this.getMemeticED(evaluations, problem);
			break;
		default:
			throw new JMetalException("Algorithm " + name + " not exists");
		}
		return builder;
	}

	private AlgorithmBuilder getDEUnicauca(int evaluations, DoubleProblem problem) {
		return new DEUnicaucaBuilder(problem).setPopulationSize(POPULATION_DE)
				.setCrossover(new DifferentialEvolutionCrossover(crDe, fDe, "rand/1/bin"))
				.setSelection(new DifferentialEvolutionSelection()).setMaxEvaluations(evaluations)
				.setPenalizeValue(PENALIZE_VALUE).setComparator(COMPARATOR);
	}

	private AlgorithmBuilder getSaDE(int evaluations, DoubleProblem problem) {
		return new SaDEBuilder(problem).setPopulationSize(populationSaDE)
				.setCrossoverOperator(new DifferentialEvolutionCrossover(cR1SADE, f1SADE, "rand/1/bin"))
				.setCrossoverOperator2(new DifferentialEvolutionCrossover(cR2SADE, f2SADE, "current-to-best/1/bin"))
				.setSelectionOperator(new DifferentialEvolutionSelection()).setMaxEvaluations(evaluations)
				.setPenalizeValue(PENALIZE_VALUE).setComparator(COMPARATOR);
	}

	private AlgorithmBuilder getSaNSDE(int evaluations, DoubleProblem problem) {
		return new SaNSDEBuilder(problem).setPopulationSize(populationSANSDE)
				.setCrossover(new DifferentialEvolutionCrossover(cR1SANSDE, f1SANSDE, "rand/1/bin"))
				.setCrossoverOperator2(new DifferentialEvolutionCrossover(cR2SANSDE, f2SANSDE, "current-to-best/1/bin"))
				.setSelection(new DifferentialEvolutionSelection()).setMaxEvaluations(evaluations)
				.setPenalizeValue(PENALIZE_VALUE).setComparator(COMPARATOR);
	}

	private AlgorithmBuilder getDECCG(int evaluations, DoubleProblem problem) {
		DECC_GBuilder builder = new DECC_GBuilder(problem)
				.setDEBuilder(new DEUnicaucaBuilder(problem)
						.setCrossover(new DifferentialEvolutionCrossover(crDe, fDe, "rand/1/bin"))
						.setSelection(new DifferentialEvolutionSelection()))
				.setSaNSDEBuilder(
						new SaNSDEBuilder(problem)
								.setCrossover(new DifferentialEvolutionCrossover(cR1SANSDE, f1SANSDE, "rand/1/bin"))
								.setCrossoverOperator2(new DifferentialEvolutionCrossover(cR2SANSDE, f2SANSDE,
										"current-to-best/1/bin")))
				.setMaxEvaluations(evaluations).setPenalizeValue(PENALIZE_VALUE).setComparator(COMPARATOR);

		if (evaluatorType == AbstractELMEvaluator.EvaluatorType.CV) {
			builder.setPopulationSize(dECCGPOPULATION).setSubcomponets(6).setFEs(30).setwFes(40);
		} else {
			builder.setPopulationSize(dECCGPOPULATION).setSubcomponets(10).setFEs(70).setwFes(100);
		}

		return builder;
	}

	private AlgorithmBuilder getMemeticED(int evaluations, DoubleProblem problem) {
		return new MemeticEDBuilder(problem).setPopulationSize(populationMemetic)
				.setCrossover(new DifferentialEvolutionCrossover(cRMEMETICDE, fMEMETICDE, "current-to-best/1/bin"))
				.setSelection(new DifferentialEvolutionSelection()).setMaxEvaluations(evaluations - 1)
				.setComparator(COMPARATOR_MEMETIC);
	}

	@Override
	protected void loadAlgorithmValues(String name, AbstractELMEvaluator.EvaluatorType evaluatorType) throws Exception {

		crDe = parametersFactory.getValue("CR", evaluatorType, "DEUnicauca");
		fDe = parametersFactory.getValue("F", evaluatorType, "DEUnicauca");
		POPULATION_DE = (int) parametersFactory.getValue("POPULATION", evaluatorType, "DEUnicauca");

		cR1SADE = parametersFactory.getValue("CR1", evaluatorType, "SaDE");
		f1SADE = parametersFactory.getValue("F1", evaluatorType, "SaDE");
		cR2SADE = parametersFactory.getValue("CR2", evaluatorType, "SaDE");
		f2SADE = parametersFactory.getValue("F2", evaluatorType, "SaDE");
		populationSaDE = (int) parametersFactory.getValue("POPULATION", evaluatorType, "SaDE");

		cR1SANSDE = parametersFactory.getValue("CR1", evaluatorType, "SaNSDE");
		f1SANSDE = parametersFactory.getValue("F1", evaluatorType, "SaNSDE");
		cR2SANSDE = parametersFactory.getValue("CR2", evaluatorType, "SaNSDE");
		f2SANSDE = parametersFactory.getValue("F2", evaluatorType, "SaNSDE");
		populationSANSDE = (int) parametersFactory.getValue("POPULATION", evaluatorType, "SaNSDE");

		cRMEMETICDE = parametersFactory.getValue("CR", evaluatorType, "MemeticED");
		fMEMETICDE = parametersFactory.getValue("F", evaluatorType, "MemeticED");
		populationMemetic = (int) parametersFactory.getValue("POPULATION", evaluatorType, "MemeticED");

		dECCGPOPULATION = (int) parametersFactory.getValue("POPULATION", evaluatorType, "DECC_G");
	}

}
