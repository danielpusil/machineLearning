package co.edu.unicauca.problem.cross_validation;

import java.util.ArrayList;
import java.util.List;

import org.uma.jmetal.solution.DoubleSolution;

import co.edu.unicauca.dataset.DataSet;
import co.edu.unicauca.elm.ELM;
import co.edu.unicauca.elm.util.ELMUtil;
import co.edu.unicauca.elm_function.ELMFunction;
import co.edu.unicauca.moore.penrose.AbstractMoorePenroseMethod;
import co.edu.unicauca.problem.AbstractELMEvaluator;
import co.edu.unicauca.problem.AbstractELMEvaluator.EvaluatorType;
import no.uib.cipr.matrix.DenseMatrix;
import no.uib.cipr.matrix.DenseVector;
import no.uib.cipr.matrix.Matrices;
import no.uib.cipr.matrix.Vector;

/**
 * Elm's Evaluator using cross validation files
 */
public abstract class AbstractCrossValidationEvaluator extends AbstractELMEvaluator {

	/**
	 * -----------------------------------------------------------------------------------------
	 * Atributes
	 * -----------------------------------------------------------------------------------------
	 */
	/**
	 * Number of folders
	 */
	private int number_folders;
	/**
	 * Data sets for training ELM
	 */
	private List<DataSet> training_folders;
	/**
	 * Data sets for testing ELM
	 */
	private List<DataSet> testing_folders;

	/**
	 * -----------------------------------------------------------------------------------------
	 * Methods
	 * -----------------------------------------------------------------------------------------
	 */
	/**
	 * Creates a cross validation evaluator
	 *
	 * @param type
	 * @param name
	 * @param trainingDataSet
	 * @param testingDataSet
	 * @param numberFolders
	 * @param hiddenNeurons
	 * @param activationFunction
	 * @param inverse
	 * @param maxEvaluations     Maximun number of evaluations for objective
	 *                           function
	 */
	public AbstractCrossValidationEvaluator(EvaluatorType type, String name, DataSet trainingDataSet,
			DataSet testingDataSet, int numberFolders, int hiddenNeurons, ELMFunction activationFunction,
			AbstractMoorePenroseMethod inverse, int maxEvaluations) {

		super(type, name, trainingDataSet, testingDataSet);
		this.number_folders = numberFolders;
		super.elm = new ELM(ELMUtil.getELMType(trainingDataSet), hiddenNeurons, activationFunction,
				trainingDataSet.getNumberClasses(), inverse);
		int inputNeuron = trainingDataSet.getX().numRows();
		super.elm.setInputNeurons(inputNeuron);
		makeFolders();
		super.loadInitalConfiguration();
	}

	private void makeFolders() {
		training_folders = new ArrayList<>();
		testing_folders = new ArrayList<>();
		int trainig_size = super.trainingDataSet.getX().numColumns();
		int number_variables = trainingDataSet.getX().numRows();
		int number_data = trainingDataSet.getX().numColumns();
		int number_clases = trainingDataSet.getNumberClasses();
		DenseMatrix x = trainingDataSet.getX();
		DenseVector y = trainingDataSet.getY();
		int aditionals = number_data % number_folders;
		int sizeFolder = number_data / number_folders;

		for (int i = 0; i < number_folders; i++) {
			if (i < aditionals) {
				training_folders.add(new DataSet((sizeFolder * (number_folders - 1)) + (aditionals - 1),
						number_variables, number_clases));
				testing_folders.add(new DataSet(sizeFolder + 1, number_variables, number_clases));
			} else {
				training_folders.add(
						new DataSet((sizeFolder * (number_folders - 1)) + aditionals, number_variables, number_clases));
				testing_folders.add(new DataSet(sizeFolder, number_variables, number_clases));
			}
		}

		for (int i = 0; i < trainig_size; i++) {
			Vector data = Matrices.getColumn(x, i);
			double value = y.get(i);
			int result = i % number_folders;
			for (int j = 0; j < number_folders; j++) {

				if (result != j) {
					DataSet training = training_folders.get(j);
					training.addDataColumn(data);
					training.addValueColumn(value);
					training.nextIndex();
				} else {
					DataSet testing = testing_folders.get(j);
					testing.addDataColumn(data);
					testing.addValueColumn(value);
					testing.nextIndex();
				}

			}
		}

	}

	@Override
	public double train() {
		double accuracy = 0.0;
		for (int i = 0; i < number_folders; i++) {
			DataSet training = training_folders.get(i);
			DataSet testing = testing_folders.get(i);
			elm.setX(training.getX());
			elm.setY(training.getY());
			elm.train();
			elm.setX(testing.getX());
			elm.setY(testing.getY());
			elm.test();
			accuracy += elm.getAccuracy();
		}

		return (double) (accuracy / (double) number_folders);
	}

	@Override
	public double test(DoubleSolution solution) {
		super.getInputWeightsBiasFrom(solution);
		elm.setInputWeight(inputWeights);
		elm.setBiasHiddenNeurons(bias);
		elm.setX(trainingDataSet.getX());
		elm.setY(trainingDataSet.getY());
		elm.train();
		elm.setX(testingDataSet.getX());
		elm.setY(testingDataSet.getY());
		elm.test();
		return elm.getAccuracy();
	}
}
